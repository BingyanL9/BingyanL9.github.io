---
layout: post
title:  "Java CG"
date:   2021-02-19 21:18:54
categories: Java
tags: Java
excerpt: Java CG
mathjax: true
---

* content
{:toc}

> JAVA CG

## CG算法和收集器

1. 如何判断对象可以被回收

    · 引用计数法： 给对象添加一个引用计数器，每当一个地方引用，计数器就加1。当引用失效，计数器减1.任何时候计数器为0的对象就不可能再被使用。

        使用简单，效率高。这是早期的策略，现在主流的虚拟机中没有选择这个算法来管理内存的了。主要的原因是无法解决循环引用的问题。

    · 可达性分析： 通过一系列的 CG Roots 的对象最为起点，从这些节点开始向下检索，节点所走过的路径称为引用链（强引用），当一个对象到 CG Roots 节点没有引用链相连的话，则证明此对象是不可用。

        CG Roots 根节点： 类加载器、Thread、 虚拟机本栈的局部变量表、static成员、 常量引用、本地方法栈的变量等。

2. 引用类型

· 强引用： 在程序代码中普遍存在的，类似 Object obj = new Object() 这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

· 软引用： 用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。

· 弱引用： 用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。

· 虚引用： 也叫幽灵引用或幻影引用（名字真会取，很魔幻的样子），是最弱的一种引用 关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。它的作用是能在这个对象被收集器回收时收到一个系统通知。

3. 如何判断一个常量是废弃常量

运行时常量池只要回收的就是废弃常量。场景如下：

假如在常量池中存在字符串“abc”，如果当时没有任何String对象引用该字符串常量的话，就说明常量“abc”就是废弃常量，假如这发生内存回收，而且有必要的话，“abc”会被系统清除出常量池。

4. 如何判断一个类无用

满足一下三个条件条件：

· 该类所有实例都已经被回收，也就是java堆中不存在该类的实例

· 加载该类的 ClassLoader已经被回收

· 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

5. 垃圾回收算法

· 标记-清除算法： 最基础的收集算法。算法分为两个阶段：标记 - 清除。对可回收的空间进行标记，进行清除。清除之后产生大量内存碎片。 

    缺点：标记和清除两个过程效率都不高，清除之后产生大量碎片。

· 复制算法： 为了解决效率问题，而提出来的算法。将内存分为大小相同两块。每次只使用其中一块。当这一块使用完了之后，将所有存活对象复制到另外一块，然后再将前面一块内存全部清空。这样就使得每一次的内存回收是对内存区域的一半进行回收。 - 年轻代的from survivor 和 to survivor区

· 标记-整理： 根据老年代的特点提出的算法。标记过程和“标记 - 清除”算法一样。但是后续步骤不是直接对可回收对象进行回收，而是让所有存活的对象向一段移动，然后直接清理掉边界外的内存。 代价大，出现停顿时间。

· 分代算法： 根据存活周期的不同，将内存分为几块。新生代和老年代。各个年代的垃圾回收算法不一样。

    在新生代中，对象比较活跃，周期比较短，每次收集都会有大量的对象死去。所以选择复制算法，付出少量对象的复制的成本就可以完成每次垃圾回收。而老年代的对象存活几率比较高，而没有额外的空间对它进行分配担保。使用标记整理算法。会有STW。

    分配担保： 大的对象第一次分配会分配到新生代，如果能够放得下。再来别的对象的话，这个对象会直接分配到老年代。这样担保年轻代不会oom。

6. 垃圾回收器

· serial (Y)：以前：新生代-复制；老年代-标记-整理。 现在用于新生代。串行，单线程，会停掉所有用户线程，会有STW。直到最后结束为止。以前的条件下-简单高效。

· parNew [并行](Y)：以前：新生代-复制；老年代-标记-整理。 现在用于新生代。多线程版本serial。 会有STW。吞吐量还是不够。

· parallel Scavenge (Y)：以前：新生代-复制；老年代-标记-整理。jdk 8默认收集器。关注吞吐量。完全实现并行，多条垃圾收集线程并行。提供众多参数，供用户找出最合适的停顿时间和最大吞吐量。

· serial old (O)：

· parallel old (O)：

· CMS (O)： 服务器适合使用。并发（用户线程和垃圾回收线程一起跑），STW时间变短，标记 - 清除算法。分为以下阶段

    1. 初始标记： 暂停所有的其他线程，并记录下当前与root相连的对象，速度很快。

    2. 并发阶段： 同时开始CG和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有可达对象，因为用户线程可能会不断的更新引用域，所以此时GC无法保证可达性分析的实时性，所以这个算法里会跟踪记录这些发生引用更新的地方。

    3. 重新标记： 重新标记阶段就是为了修正并发时期因为用户程序继续运行而导致标记产生变化的那部分对象的标记记录。这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。

    4. 并发清除：开启用户线程，同时GC线程开始对为标记区域做清扫。

    缺点： 
    
        对cpu资源敏感

        无法浮动垃圾。运行过程中会产生垃圾

        标记-清除会有大量的空间碎片

· G1 (O/Y) 优先处理那些垃圾多的内存块： 面向服务器。不是分代，分region（Eden, Survivor, Old, Humongous)，每个region使用的内存大小差不多。分配担保机制被humongous代替。G1把内存划分成很多小块, 每个小块会被标记为E/S/O中的一个，可以前面一个是Eden后面一个就变成Survivor了。 局部复制，全局标记整理来实现的。 https://www.cnblogs.com/aspirant/p/8663872.html

    Humongous： 存储的是巨大对象. 即大小大于等于region一半的对象， 

    特点： 

    1. 可以有效的规避内存碎片的问题，由于内存被分成了很多小块，内存块比较小，进行内存压缩整理的代价都比较小

    2. 可预测停顿（这是相对于GMS的另外一个优势，能够建立可预测的停顿时间模型，能让使用者明确指定在一个时间M毫秒的时间段内的停顿时间，G1每次并不会回收整代内存，到底回收多少内存就看用户配置的暂停时间，配置的时间短就少回收点，配置的时间长就多回收点，伸缩自如）

    MixGC是这个收集器特有的。


    步骤

        1. 初始标记

        2. 并发标记

        3. 最终标记

        4. 筛选回收： G1收集器在后台维护了一个优先列表，每次根据允许收集时间内有限选择回收价值最大的Region（Garbage-First的由来）。这种使用region划分内存空间以及有优先级的区域回收方式，保证了GC收集器在有限的时间内尽可能高的回收效率。

    缺点： 垃圾收集次数变多，如果应用的内存非常吃紧，对内存进行部分回收根本不够，始终要进行整个Heap的回收，那么G1要做的工作量就一点也不会比其它垃圾回收器少，而且因为本身算法复杂了一点，可能比其它回收器还要差。因此G1比较适合内存稍大一点的应用(一般来说至少4G以上)，小内存的应用还是用传统的垃圾回收器比如CMS比较合适。

7. 怎么选择垃圾收集器

    1. 优先调整堆的大小让服务器自己来选择

    2. 如果内存小于100m，使用串行收集器

    3. 如果单核，并且没有停顿时间要求，串行或jvm自己选择

    4. 如果允许停顿时间操作1s，选择并行或jvm自己选择

    5. 如果响应时间最重要，并且不能超过1s，使用并发收集器。




