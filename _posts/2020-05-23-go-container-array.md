---
layout: post
title:  "Go - 容器 - 数组和切片"
date:   2020-05-23 21:18:54
categories: Go Foundation
tags: Notes Go Array Slice
excerpt: Go - 容器 - 数组和切片
mathjax: true
---


* content
{:toc}

> 数组和切片是 Go 语言中常见的数据结构， 他们是两个概念。 数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，所以在Go语言中很少直接使用数组。和数组对应的类型是 Slice（切片），Slice 是可以增长和收缩的动态序列，功能也更灵活。切片就是动态数组，它的长度并不固定，我们可以随意向切片中追加元素，而切片会在容量不足时自动扩容。

### **数组**

#### 数组的声明

```
var arrayName [length]type
eg: var a [10]int

arrayName：数组声明及使用时的变量名。
length：数组的元素数量，可以是一个表达式，但最终通过编译期计算的结果必须是整型数值，元素数量不能含有到运行时才能确认大小的数值。
Type：可以是任意基本类型，包括数组本身，类型为数组本身时，可以实现多维数组。

len(a) 可以返回数组长度
```

#### 数组的初始化

```
var q [3]int = [3]int{1, 2, 3}
var r [3]int = [3]int{1, 2}

fmt.Println(r(2))//0

在数组的定义中，如果在数组长度的位置出现“...”省略号，则表示数组的长度是根据初始化值的个数来计算:
q := [...]int{1, 2, 3}
fmt.Printf("%T\n", q) // "[3]int"

数组的长度是数组类型的一个组成部分，因此 [4]int 和 [3]int 是两个不同类型。
```

与很多语言不同，Go 语言中数组在初始化之后大小就无法改变，存储元素类型相同、但是大小不同的数组类型在 Go 语言看来也是完全不同的，只有两个条件都相同才是同一个类型。

```
// NewArray returns a new fixed-length array Type.
func NewArray(elem *Type, bound int64) *Type {
	if bound < 0 {
		Fatalf("NewArray: invalid bound %v", bound)
	}
	t := New(TARRAY)
	t.Extra = &Array{Elem: elem, Bound: bound}
	t.SetNotInHeap(elem.NotInHeap())
	return t
}
```

编译期间的数组类型由上面的```cmd/compile/internal/types/type.NewArray```函数生成，类型 Array 包含两个字符：一个元素类型 Elem, 一个元素个数，也即是数组大小 Bound。这两个字段共同构成了数组类型。 

我们已经知道数组的创建有两种方式了，一种是显式的指定数组的大小，另一种是使用 ```[...]T``` 声明数组，那么这两种创建方式有何不同呢？

上述两种声明方式在**运行期间**得到的结果是完全相同的，后一种声明方式在编译期间就会被『转换』成为前一种，这也就是编译器对数组大小的推导。

对于一个由字面量组成的数组，根据数组元素数量的不同，编译器会做两种不同的优化：

当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上；
当元素数量大于 4 个时，会将数组中的元素放置到静态区并在运行时取出；

#### 比较两个数组是否相等

如果两个数组类型相同（包括数组的长度，数组中元素的类型）的情况下，我们可以直接通过较运算符（==和!=）来判断两个数组是否相等，只有当两个数组的所有元素都是相等的时候数组才是相等的，不能比较两个类型不同的数组，否则程序将无法完成编译。

#### 遍历数组

```
var team [3]string

team[0] = "hammer"
team[1] = "soldier"
team[2] = "mum"

for i,v := range team{
    fmt.Println(i, v)
}
```

### **切片**

Go语言中切片的内部结构包含地址、大小和容量，切片一般用于快速地操作一块数据集合，如果将数据集合比作切糕的话，切片就是你要的“那一块”，切的过程包含从哪里开始（切片的起始位置）及切多大（切片的大小），容量可以理解为装切片的口袋大小。

#### 声明

在 Go 语言中，切片类型的声明方式与数组有一些相似，由于切片的长度是动态的，所以声明时只需要指定切片中的元素类型：

```
[]int
[]interface{}
```

从切片的定义我们能推测出，切片在编译期间的生成的类型只会包含切片中的元素类型，即 int 或者 interface{} 等。```cmd/compile/internal/types/type.NewSlice``` 就是编译期间用于创建 Slice 类型的函数：

```
func NewSlice(elem *Type) *Type {
	if t := elem.Cache.slice; t != nil {
		if t.Elem() != elem {
			Fatalf("elem mismatch")
		}
		return t
	}

	t := New(TSLICE)
	t.Extra = Slice{Elem: elem}
	elem.Cache.slice = t
	return t
}
```

#### 初始化

Go 语言中的切片有三种初始化的方式：

- 通过下标的方式获得数组或者切片的一部分；

    ```
    arr[0:3] or slice[0:3]

    从数组或切片生成新的切片拥有如下特性：
    取出的元素数量为：结束位置 - 开始位置；
    取出元素不包含结束位置对应的索引，切片最后一个元素使用 slice[len(slice)] 获取；
    当缺省开始位置时，表示从连续区域开头到结束位置；
    当缺省结束位置时，表示从开始位置到整个连续区域末尾；
    两者同时缺省时，与切片本身等效；
    两者同时为 0 时，等效于空切片，一般用于切片复位。
    ```

- 使用字面量初始化新的切片；

    ```
    slice := []int{1, 2, 3}
    ```

- 使用关键字 make 创建切片：

    ```
    slice := make([]int, 10)
    ```


#### 追加和扩容

在 Go 语言中我们会使用 append 关键字向切片追加元素.

```
var a []int
a = append(a, 1) // 追加1个元素
a = append(a, 1, 2, 3) // 追加多个元素, 手写解包方式
a = append(a, []int{1,2,3}...) // 追加一个切片, 切片需要解包
```
除了在切片的尾部追加，我们还可以在切片的开头添加元素：
```
var a = []int{1,2,3}
a = append([]int{0}, a...) // 在开头添加1个元素
a = append([]int{-3,-2,-1}, a...) // 在开头添加1个切片
```
在切片开头添加元素一般都会导致内存的重新分配，而且会导致已有元素全部被复制 1 次，因此，从切片的开头添加元素的性能要比从尾部追加元素的性能差很多。

因为 append 函数返回新切片的特性，所以切片也支持链式操作，我们可以将多个 append 操作组合起来，实现在切片中间插入元素：

```
var a []int
a = append(a[:i], append([]int{x}, a[i:]...)...) // 在第i个位置插入x
a = append(a[:i], append([]int{1,2,3}, a[i:]...)...) // 在第i个位置插入切片
```
不过需要注意的是，在使用 append() 函数为切片动态添加元素时，如果空间不足以容纳足够多的元素，切片就会进行“扩容”，此时新切片的长度会发生改变。

在分配内存空间之前需要先确定新的切片容量，Go 语言根据切片的当前容量选择不同的策略进行扩容：

如果期望容量大于当前容量的两倍就会使用期望容量；
如果当前切片容量小于 1024 就会将容量翻倍；
如果当前切片容量大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；

#### 切片复制

Go语言的内置函数 copy() 可以将一个数组切片复制到另一个数组切片中，如果加入的两个数组切片不一样大，就会按照其中较小的那个数组切片的元素个数进行复制。

```
copy( destSlice, srcSlice []T) int
```

其中 srcSlice 为数据来源切片，destSlice 为复制的目标（也就是将 srcSlice 复制到 destSlice），目标切片必须分配过空间且足够承载复制的元素个数，并且来源和目标的类型必须一致，copy() 函数的返回值表示实际发生复制的元素个数。

```
slice1 := []int{1, 2, 3, 4, 5}
slice2 := []int{5, 4, 3}
copy(slice2, slice1) // 只会复制slice1的前3个元素到slice2中 //slice2 ==> {1, 2, 3}
copy(slice1, slice2) // 只会复制slice2的3个元素到slice1的前3个位置 //slice1 ==> {1, 2, 3, 4, 5}
```

#### 从切片中删除一个元素

Go语言并没有对删除切片元素提供专用的语法或者接口，需要使用切片本身的特性来删除元素，根据要删除元素的位置有三种情况，分别是从开头位置删除、从中间位置删除和从尾部删除，其中删除切片尾部的元素速度最快。

- 从开头位置删除

```
a = []int{1, 2, 3}
a = a[1:] // 删除开头1个元素
a = a[N:] // 删除开头N个元素

a = []int{1, 2, 3}
a = append(a[:0], a[1:]...) // 删除开头1个元素
a = append(a[:0], a[N:]...) // 删除开头N个元素
```

- 从中间位置删除

```
a = []int{1, 2, 3, ...}
a = append(a[:i], a[i+1:]...) // 删除中间1个元素
a = append(a[:i], a[i+N:]...) // 删除中间N个元素

a = a[:i+copy(a[i:], a[i+1:])] // 删除中间1个元素
a = a[:i+copy(a[i:], a[i+N:])] // 删除中间N个元素

```

- 从尾部删除

```
a = []int{1, 2, 3}
a = a[:len(a)-1] // 删除尾部1个元素
a = a[:len(a)-N] // 删除尾部N个元素
```

连续容器的元素删除无论在任何语言中，都要将删除点前后的元素移动到新的位置，随着元素的增加，这个过程将会变得极为耗时，因此，当业务需要大量、频繁地从一个切片中删除元素时，如果对性能要求较高的话，就需要考虑更换其他的容器了（如双链表等能快速从删除点删除元素）。

### 笔记来源

[C 语言中文网：Go语言数组详解](http://c.biancheng.net/view/26.html)

[C 语言中文网:Go语言切片详解](http://c.biancheng.net/view/27.html)

[C 语言中文网:Go语言append()为切片添加元素](http://c.biancheng.net/view/28.html)

[Go 语言中文网:Go语言copy()：切片复制（切片拷贝）](http://c.biancheng.net/view/29.html)

[Go 语言中文网:Go语言从切片中删除元素](http://c.biancheng.net/view/30.html)

[面向信仰编程:3.1 数组](https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array/)

[面向信仰编程:3.2 切片](https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/)

