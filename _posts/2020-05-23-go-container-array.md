---
layout: post
title:  "Go - 容器 - 数组和切片"
date:   2020-05-23 21:18:54
categories: Go Foundation
tags: Notes Go Array Slice
excerpt: Go - 容器 - 数组和切片
mathjax: true
---


* content
{:toc}

> 数组和切片是 Go 语言中常见的数据结构， 他们是两个概念。 数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，所以在Go语言中很少直接使用数组。和数组对应的类型是 Slice（切片），Slice 是可以增长和收缩的动态序列，功能也更灵活。切片就是动态数组，它的长度并不固定，我们可以随意向切片中追加元素，而切片会在容量不足时自动扩容。

### **数组**

#### 数组的声明

```
var arrayName [length]type
eg: var a [10]int

arrayName：数组声明及使用时的变量名。
length：数组的元素数量，可以是一个表达式，但最终通过编译期计算的结果必须是整型数值，元素数量不能含有到运行时才能确认大小的数值。
Type：可以是任意基本类型，包括数组本身，类型为数组本身时，可以实现多维数组。

len(a) 可以返回数组长度
```

#### 数组的初始化

```
var q [3]int = [3]int{1, 2, 3}
var r [3]int = [3]int{1, 2}

fmt.Println(r(2))//0

在数组的定义中，如果在数组长度的位置出现“...”省略号，则表示数组的长度是根据初始化值的个数来计算:
q := [...]int{1, 2, 3}
fmt.Printf("%T\n", q) // "[3]int"

数组的长度是数组类型的一个组成部分，因此 [4]int 和 [3]int 是两个不同类型。
```

与很多语言不同，Go 语言中数组在初始化之后大小就无法改变，存储元素类型相同、但是大小不同的数组类型在 Go 语言看来也是完全不同的，只有两个条件都相同才是同一个类型。

```
// NewArray returns a new fixed-length array Type.
func NewArray(elem *Type, bound int64) *Type {
	if bound < 0 {
		Fatalf("NewArray: invalid bound %v", bound)
	}
	t := New(TARRAY)
	t.Extra = &Array{Elem: elem, Bound: bound}
	t.SetNotInHeap(elem.NotInHeap())
	return t
}
```

编译期间的数组类型由上面的```cmd/compile/internal/types/type.NewArray```函数生成，类型 Array 包含两个字符：一个元素类型 Elem, 一个元素个数，也即是数组大小 Bound。这两个字段共同构成了数组类型。 

我们已经知道数组的创建有两种方式了，一种是显式的指定数组的大小，另一种是使用 ```[...]T``` 声明数组，那么这两种创建方式有何不同呢？

上述两种声明方式在**运行期间**得到的结果是完全相同的，后一种声明方式在编译期间就会被『转换』成为前一种，这也就是编译器对数组大小的推导。

对于一个由字面量组成的数组，根据数组元素数量的不同，编译器会做两种不同的优化：

当元素数量小于或者等于 4 个时，会直接将数组中的元素放置在栈上；
当元素数量大于 4 个时，会将数组中的元素放置到静态区并在运行时取出；

#### 比较两个数组是否相等

如果两个数组类型相同（包括数组的长度，数组中元素的类型）的情况下，我们可以直接通过较运算符（==和!=）来判断两个数组是否相等，只有当两个数组的所有元素都是相等的时候数组才是相等的，不能比较两个类型不同的数组，否则程序将无法完成编译。

#### 遍历数组

```
var team [3]string

team[0] = "hammer"
team[1] = "soldier"
team[2] = "mum"

for i,v := range team{
    fmt.Println(i, v)
}
```

### **切片**

Go语言中切片的内部结构包含地址、大小和容量，切片一般用于快速地操作一块数据集合，如果将数据集合比作切糕的话，切片就是你要的“那一块”，切的过程包含从哪里开始（切片的起始位置）及切多大（切片的大小），容量可以理解为装切片的口袋大小。

#### 声明

在 Go 语言中，切片类型的声明方式与数组有一些相似，由于切片的长度是动态的，所以声明时只需要指定切片中的元素类型：

```
[]int
[]interface{}
```

从切片的定义我们能推测出，切片在编译期间的生成的类型只会包含切片中的元素类型，即 int 或者 interface{} 等。```cmd/compile/internal/types/type.NewSlice``` 就是编译期间用于创建 Slice 类型的函数：

```
func NewSlice(elem *Type) *Type {
	if t := elem.Cache.slice; t != nil {
		if t.Elem() != elem {
			Fatalf("elem mismatch")
		}
		return t
	}

	t := New(TSLICE)
	t.Extra = Slice{Elem: elem}
	elem.Cache.slice = t
	return t
}
```

#### 初始化

Go 语言中的切片有三种初始化的方式：

- 通过下标的方式获得数组或者切片的一部分；

    ```
    arr[0:3] or slice[0:3]

    从数组或切片生成新的切片拥有如下特性：
    取出的元素数量为：结束位置 - 开始位置；
    取出元素不包含结束位置对应的索引，切片最后一个元素使用 slice[len(slice)] 获取；
    当缺省开始位置时，表示从连续区域开头到结束位置；
    当缺省结束位置时，表示从开始位置到整个连续区域末尾；
    两者同时缺省时，与切片本身等效；
    两者同时为 0 时，等效于空切片，一般用于切片复位。
    ```

- 使用字面量初始化新的切片；

    ```
    slice := []int{1, 2, 3}
    ```

- 使用关键字 make 创建切片：

    ```
    slice := make([]int, 10)
    ```


#### 追加和扩容

在 Go 语言中我们会使用 append 关键字向切片追加元素.

在分配内存空间之前需要先确定新的切片容量，Go 语言根据切片的当前容量选择不同的策略进行扩容：

如果期望容量大于当前容量的两倍就会使用期望容量；
如果当前切片容量小于 1024 就会将容量翻倍；
如果当前切片容量大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；



