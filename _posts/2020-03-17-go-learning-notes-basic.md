---
layout: post
title:  "Go - 简介"
date:   2020-03-20 21:18:54
categories: Foundation Go
tags: Notes Go Basic
excerpt: Go 语言不仅可以访问底层操作系统，还提供强大的网络编程和并发编程的支持。可以进行网络编程、系统编程、并发编程、分布式编程。目前很多重要的开源项目都是使用 Go 语言进行开发如 Go语言、Docker、Kubernate、etcd等。毫不夸张的说，要学习并理解云服务相关的技术，学习 Go 是必不可少的。
mathjax: true
---

* content
{:toc}

> Go 语言不仅可以访问底层操作系统，还提供强大的网络编程和并发编程的支持。可以进行网络编程、系统编程、并发编程、分布式编程。目前很多重要的开源项目都是使用 Go 语言进行开发如 Go语言、Docker、Kubernate、etcd等。毫不夸张的说，要学习并理解云服务相关的技术，学习 Go 是必不可少的。

## 简介

Go 语言起源于2007年，并与2009年正式对外开发。 其主要目标是： 既有动态语言的开发速度又有编译型语言的性能和安全。 Go 语言是以C语言的基础，使用 Go 语言开发出来的一门语言。 Go 语言从C语言继承了表达式语法、控制流结构、基本数据类型、调用参数传值、**指针**等思想。

Go语言也称为 Golang，是一种静态强类型、编译型、并发型、并具有垃圾回收功能的编程语言， **自带了编译器**，因此无须单独安装编译器。支持交叉编译，比如说你可以在运行 Linux 系统的计算机上开发可以在 Windows 上运行的应用程序。

这是第一门完全支持 UTF-8 的编程语言，这不仅体现在它可以处理使用 UTF-8 编码的字符串，就连它的源码文件格式都是使用的 UTF-8 编码。

## 特点

**语法简单**：将“++”、“--”从运算符降级为语句，保留指针，但默认阻止指针运算，将切片和字典作为内置类型，从运行时的层面进行优化。

**并发模型**： 运行时用 **Goroutine** 并发运行所有的一切，包括 main.main 入口函数。Goroutine 是 Go 最显著的特征。它用类协程的方式来处理并发单元，却又在运行时层面做了更深度的优化处理。

**内存分配**: 运用 **tcmalloc** 进行内存分配。**tcmalloc** 原先就是为了并发而设计的高性能内存分配组件。

**垃圾回收**:  Go 从 1.5 版本开始实现并发标记，逐步引入三色标记和写屏障等等。 依旧在优化中。

**静态链接**: 将运行时、依赖库直接打包到可执行文件内部，简化了部署和发布操作，无须事先安装运行环境和下载诸多第三方库。 动态链接库 buildmode 在完善中。

## Go语言内置并发

在多核 CPU 时代， 大部分语言都没有有效的工具让程序可以轻易的利用多核的 CPU 资源，编写正确同步代码并不容易。Go 语言在这样的背景下诞生，从底层原生支持并发编程，无需第三方库， 开发人员可以很很轻松的决定怎么使用 CPU 。 

Go 语言的并发基于  **Goroutine**，Go语言运行时会参与调度 goroutine，并将 goroutine 合理地分配到每个 CPU 中，最大限度地使用 CPU 性能。

多个 goroutine 中，Go语言使用通道（channel）进行通信，通道是一种内置的数据结构，可以让用户在不同的 goroutine 之间同步发送具有类型的消息， 从而实现多个 goroutine 之间内存共享。在 goroutine 之间发送消息，而不是让多个 goroutine 争夺同一个数据的使用权。

![](\images\go-basic\channel.png)

## 使用 Go 语言开发的项目

**Docker**: https://github.com/docker/docker

**Go语言**: https://github.com/golang/go

**Kubernetes**: https://github.com/kubernetes/kubernetes

**etcd**: 款分布式、可靠的 Key-Value 存储系统，可以快速进行云配置。 https://github.com/coreos/etcd

**beego**: beego 是一个类似 Python 的 Tornado 框架，采用了 RESTFul 的设计思路，使用Go语言编写的一个极轻量级、高可伸缩性和高性能的 Web 应用框架. https://github.com/astaxie/beego

**martini**: 一款快速构建模块化的 Web 应用的Go语言框架。https://github.com/go-martini/martini

**codis**: 国产的优秀分布式 Redis 解决方案. https://github.com/CodisLabs/codis

**delve**: Go语言的调试器. https://github.com/derekparker/delve

其他开源项目：
云计算基础设施领域，代表项目 consul、cloudflare CDN、七牛云存储等。
基础软件，代表项目：tidb、influxdb、cockroachdb 等。
微服务，代表项目：go-kit、micro、monzo bank 的 typhon、bilibili 等。
互联网基础设施，代表项目：以太坊、hyperledger 等。

## 与主流的语言相比Go 语言的优劣

- **优点**：  

    1) 相对于 C/C++ 来讲，Go语言拥有清晰的依赖管理和全自动的垃圾回收机制，因此其代码量大大降低，开发效率大大提高。

    2) 相对于 Java 来讲，Go语言拥有简明的类型系统、函数式编程范式和先进的并发编程模型。因此其代码块更小更简洁、可重用性更高，并可在多核计算环境下更快地运行。

    3) 对于 PHP 来讲，Go语言更具通用性和规范性。这使得其更适合构建大型的软件，并能够更好地将各个模块组织在一起。在性能方面，PHP 不可与 Go 同日而语。

    4) 对于 Python/Ruby 来讲，Go 的优势在于其简洁的语法、非侵入式和扁平化的类型系统和浑然天成的多范式编程模型。与 PHP 一样，Python 和 Ruby 也是动态类型的解释型语言，这就意味着它们的运行速度会比静态类型的编译型语言慢很多。

    总而言之，Go语言对于当前大多数主流语言来讲，最大的优势在于具有**较高的生产效率**、**先进的依赖管理和类型系统**，以及**原生的并发计算支持**。

- **劣势**

    1）从分布式计算的角度来看，Go语言的成熟度不及 Erlang。

    2）从程序运行速度的角度来看，Go语言虽然已与 Java 不相上下，但还不及 C（差距正在不断地缩小）。

    3）从第三方库的角度来看，Go语言的库数量还远远不及其他几门主流语言（比如 Java、Python、Ruby 等）。

    4）从语言语法角度来看，Go语言语法里的语法糖并不多，变量赋值方式多得有点儿累赘了。**Go语言不支持自定义的泛型类型**。

    5) 从垃圾回收角度看，Go语言的垃圾回收采用的是并发的标记清除算法（Concurrent Mark and Sweep，CMS）。虽然是并发的操作，时间比串行操作短很多，但是还是会在垃圾回收期间停止所有用户程序的操作。这一点多少会影响到对实时性要求比较高的应用。

## 性能

通过对 C(gcc)、C++、Java、JavaScript 和Go语言的测试。性能比较如下表所示，表中数据的单位为秒，数值越小表明运行性能越好。

![](\images\go-basic\performance.png)

## 标准库

| Go语言标准库包名 | 功  能 |
|---------------|-------|
| bufio | 带缓冲的 I/O 操作 |
| bytes | 实现字节操作 |
| container | 封装堆、列表和环形列表等容器 |
| crypto | 加密算法 |
| database | 数据库驱动和接口 |
| debug | 各种调试文件格式访问及调试功能 |
| encoding | 常见算法如 JSON、XML、Base64 等 |
| flag | 命令行解析 |
| fmt | 格式化操作 |
| go | Go语言的词法、语法树、类型等。可通过这个包进行代码信息提取和修改 |
| html | HTML 转义及模板系统 |
| image | 常见图形格式的访问及生成 |
| io | 实现 I/O 原始访问接口及访问封装 |
| math | 数学库|
| net | 网络库，支持 Socket、HTTP、邮件、RPC、SMTP 等|
| os | 操作系统平台 *不依赖* 平台操作封装|
| path | *兼容* 各操作系统的路径操作实用函数|
| plugin | Go 1.7 加入的插件系统。支持将代码编译为插件，按需加载 |
| reflect | 语言反射支持。可以动态获得代码中的类型信息，获取和修改变量的值 |
| regexp | 正则表达式封装 |
| runtime | 运行时接口 |
| sort | 排序接口 |
| strings | 字符串转换、解析及实用函数 |
| time | 时间接口 |
| text | 文本模板及 Token 词法器 |

## Go 语言如何完成编译

### 预备知识

1. **抽象语法树**

    抽象语法树（AST），是代码语法结构的一种抽象表示，它用树状的方式表示编程语言的语法结构。如```1 * 2 + 3```解析出来的抽象语法树如下：

    ![](\images\go-basic\ast.png)

    抽象语法树中的每一个节点都表示代码中的一个元素，每一颗子树都表示一个语法元素，像一个 if else 语句。

    抽象语法树抹去了源代码中不重要的一些字符：空格、分号或者括号等等。编译器在执行完语法分析之后会输出一个抽象语法树，这个抽象语法树会辅助编译器进行语义分析，我们可以用它来确定语法正确的程序，如是否存在一些类型不匹配或不一致的问题。

2. **静态单赋值**

    静态单赋值（Static Single Assigment, SSA）是中间代码的一个特性，如果一个中间代码具有静态单赋值的特性，那么每个变量就只会被赋值一次, 并且变量需要在使用之前定义。如

    ```
    x := 1
    x := 2
    y := x
    ```
    根据分析，我们其实能够发现上述的代码并不需要第一个将 1 赋值给 x 的表达式，也就是 x := 1 这一表达式在上述的代码片段中是没有作用的。在 SSA 下，将会变成下列的形式：

    ```
    x1 := 1
    x2 := 2
    y1 := x2
    ```

    从使用 SSA 的中间代码我们就可以非常清晰地看出变量 y1 的值和 x1 是完全没有任何关系的，所以在机器码生成时就可以省略第一步，这样就能减少需要执行的指令来优化这一段代码。

    在中间代码中使用 SSA 的特性能够为整个程序实现以下的优化：

    - 常数传播（constant propagation）

    - 值域传播（value range propagation）

    - 稀疏有条件的常数传播（sparse conditional constant propagation）

    - 消除无用的程式码（dead code elimination）

    - 全域数值编号（global value numbering）

    - 消除部分的冗余（partial redundancy elimination）

    - 强度折减（strength reduction）

    - 寄存器分配（register allocation）


3. **指令集**

    不同的处理器（CPU）使用了大不相同的架构(指令集架构：计算机的抽象模型，也被称作架构或者计算机架构)和机器语言，所以很多编程语言为了在不同的机器上运行需要将源代码根据架构翻译成不同的机器代码。

    复杂指令集计算机（CISC）和精简指令集计算机（RISC）是目前的两种 CPU 区别，它们的在设计理念上会有一些不同，从名字我们就能看出来这两种不同的设计有什么区别：

    - 复杂指令集通过增加指令的数量减少需要执行的指令数

    - 精简指令集能使用更少的指令完成目标的计算任务

### 编译原理

Go 语言编译器的源代码在 ```src/cmd/compile``` 目录中, 目录下的文件共同组成了 Go 语言的编译器，编译器分为前端和后端。前端一般承担着词法分析、语法分析、类型检查和中间代码生成几部分工作，将源代码变成语言无关的中间表示，而编译器后端主要负责目标代码的生成和优化，也就是将中间代码翻译成目标机器能够运行的机器码。

Go的编译器在逻辑上可以被分成四个阶段：词法与语法分析、类型检查和 AST 转换、通用 SSA 生成和最后的机器代码生成：

![](\images\go-basic\compiler.png)

1. **词法与语法分析**

    -词法分析: 所有的编译过程其实都是从解析代码的源文件开始的，词法分析的作用就是*解析源代码文件*，它将文件中的字符串序列转换成 Token 序列，方便后面的处理和解析，我们一般会把执行词法分析的程序称为词法解析器（lexer）。

    -语法分析: 语法分析的输入就是词法分析器输出的 Token 序列，这些序列会按照顺序被语法分析器进行解析，语法的解析过程就是将词法分析生成的 Token 按照语言定义好的文法（Grammar）自下而上或者自上而下的进行规约，每一个 Go 的源代码文件最终会被归纳成一个 SourceFile 结构.

    **SourceFile** :表示一个 Go 语言源文件，它由 package 定义、多个 import 语句以及顶层的声明组成.

    ```
    SourceFile = PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" }
    ```
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    词法分析会返回一个不包含空格、换行等字符的 Token 序列，例如：package, json, import, (, io, ), …，而语法分析会把 Token 序列转换成有意义的结构体，也就是语法树

    将 Token 转换成上述 **语法树** 就会使用语法解析器，语法解析的结果其实就是上面介绍过的抽象语法树（AST），每一个 AST 都对应着一个单独的 Go 语言文件，这个抽象语法树中包括当前文件属于的包名、定义的常量、结构体和函数等。

    ```
    "json.go": SourceFile {
    PackageName: "json",
    ImportDecl: []Import{
        "io",
    },
    TopLevelDecl: ...
    }
    ```

    如果在语法解析的过程中发生了任何语法错误，都会被语法解析器发现并将消息打印到标准输出上，整个编译过程也会随着错误的出现而被中止。

2. **类型检查**

    当拿到一组文件的抽象语法树之后，Go 语言的编译器会对语法树中定义和使用的类型进行检查，类型检查分别会按照以下的顺序对不同类型的节点进行验证和处理：

    - 常量、类型和函数名及类型；
    - 变量的赋值和初始化；
    - 函数和闭包的主体；
    - 哈希键值对的类型；
    - 导入函数体；
    - 外部的声明；

    通过对整颗抽象语法树的遍历，我们在每一个节点上都会对当前子树的类型进行验证，以保证当前节点上不会出现类型错误的问题，所有的类型错误和不匹配都会在这一个阶段被发现和暴露出来，结构体是否实现了某些接口也会在这一阶段被检查出来。

    类型检查阶段不止会对节点的类型进行验证，还会展开和改写一些内建的函数，例如 ```make``` 关键字在这个阶段会根据子树的结构被替换成 ```makeslice``` 或者 ```makechan``` 等函数。

    综上，类型检查一共：

    - 对类型进行了验证工作
    - 对 AST 进行改写和处理Go语言内置的关键字


3. **中间代码生成**

    当我们将源文件转换成了抽象语法树、对整棵树的语法进行解析并进行类型检查之后，就可以认为当前文件中的代码不存在语法错误和类型错误的问题了，Go 语言的编译器就会将输入的抽象语法树转换成中间代码。

    Go语言编译器的中间代码使用了 SSA(Static Single Assignment Form) 的特性，能够比较容易的分析出代码中的无用变量和片段并对代码进行优化。

    在类型检查之后，就会通过一个名为 compileFunctions 的函数开始对整个Go语言项目中的全部函数进行编译，这些函数会在一个编译队列中等待几个后端工作协程的消费，这些 Goroutine 会将所有函数对应的 AST 转换成使用 SSA 特性的中间代码。

4. **机器码生成**

    Go语言源代码的 ```src/cmd/compile/internal``` 目录中包含了非常多机器码生成相关的包，不同类型的 CPU 分别使用了不同的包进行生成 amd64、arm、arm64、mips、mips64、ppc64、s390x、x86 和 wasm，也就是说Go语言能够在几乎全部常见的 CPU 指令集类型上运行。

    WebAssembly（Wasm）：一种在栈虚拟机上使用的二进制指令格式，它的设计的主要目标就是在 **Web 浏览器**上提供一种具有高可移植性的目标语言。Go 语言的编译器既然能够生成 Wasm 格式的指令，那么就能够运行在常见的主流浏览器中。

    使用以下命令可以将 Go 的源代码编译成能够在浏览器上运行 WebAssembly 文件：

    ```
    $ GOARCH=wasm GOOS=js go build -o lib.wasm main.go
    ```

    Go 语言经过编译还可以运行在几乎全部的主流机器上，不过对于除了 Linux 和 Darwin 之外的机器上兼容性上可能还是有一些问题，例如：**Go Plugin 至今仍然不支持 Windows8**。

### 编译器入口

Go 语言的编译器入口在 ```src/cmd/compile/internal/gc/main.go``` 文件中，这个 600 多行的 Main 函数就是 Go 语言编译器的主程序，该函数会先获取命令行传入的参数并更新编译选项和配置，随后就会开始运行 parseFiles 函数对输入的所有文件进行词法与语法分析得到文件对应的抽象语法树：

```
func Main(archInit func(*Arch)) {
	...

	lines := parseFiles(flag.Args())
```

接下来就会分九个阶段对抽象语法树进行更新和编译，就像我们在上面介绍的，整个过程会经历类型检查、SSA 中间代码生成以及机器码生成三个部分：

- 检查常量、类型和函数的类型；
- 处理变量的赋值；
- 对函数的主体进行类型检查；
- 决定如何捕获变量；
- 检查内联函数的类型；
- 进行逃逸分析；
- 将闭包的主体转换成引用的捕获变量；
- 编译顶层函数；
- 检查外部依赖的声明；

对整个编译过程有一个顶层的认识之后，我们重新回到词法和语法分析后的具体流程，在这里编译器会对生成语法树中的节点执行类型检查，除了常量、类型和函数这些顶层声明之外，它还会对变量的赋值语句、函数主体等结构进行检查

类型检查会对遍历传入节点的全部子节点，这个过程会对 make 等关键字进行展开和重写，在类型检查会改变语法树中的一些节点，不会生成新的变量或者语法树，这个过程的结束也意味着源代码中已经不存在语法错误和类型错误，中间代码和机器码都可以根据抽象语法树正常生成了。

### 总结

1. 词法分析： 源代码 -> Token序列

2. 语法分析： Token序列 -> 抽象语法树 并 检查语法错误

3. 类型检查：
    - 对类型进行了验证工作
    - 对 AST 进行改写和处理Go语言内置的关键字

4. 中间代码生成：抽象语法树 -> 中间代码 并 使用静态单赋值（SSA）优化

5. 机器码生成： 中间代码 -> 机器码

**Notes:** 我尝试看了下源码里面的main函数，确认过，看不懂。等学完之后再回来看吧。

## 笔记来源

[面向信仰编程：Go-概述](https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/#fn:1)

[C语言中文网：Go语言简介](http://c.biancheng.net/golang/intro/)

## 延伸

[知乎：学C语言写自己的K语言：编译器词法分析](https://zhuanlan.zhihu.com/p/85269128)

[维基：词法分析#token](https://zh.wikipedia.org/wiki/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90#%E6%A0%87%E8%AE%B0)




























